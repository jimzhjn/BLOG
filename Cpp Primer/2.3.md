# 2.3 复合类型

复合类型是指基于其他类型定义的类型。C++语言有几种复合类型。与我们已经掌握的变量声明相比，定义复合类型的变量要复杂很多。

## 2.3.1 引用

引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

```
int ival = 1024;
int &refVal = ival; // refVal指向ival
int &refVal2;       // 报错：引用必须被初始化
```

### 引用即别名

引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：

```
refVal = 2;       // 把2赋给refVal指向的对象，此处即是赋给了iVal
int ii = refVal;  // 与ii = iVal执行结果一样
```

为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。

因为引用本身不是一个对象，因此不能定义引用的引用。

### 引用的定义

允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头：

```
int i = 1024, i2 = 2048;    // i和i2都是int
int &r = i, r2 = i2;        // r是一个引用，与i绑定在一起，r2是int  
int i3 = 1024, &ri = i3;    // i3是int，ri是一个引用，与i3绑定在一起
int &r3 = i3, &r4 = i2;     // r3和r4都是引用
```

## 2.3.2 指针

指针是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方法将声明符写成\*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号\*：

```
int *ip1, *ip2;   // ip1和ip2都是指向int型对象的指针
double dp, *dp2;  // dp2是指向double型对象的指针，dp是double型对象
```

### 获取对象的地址

指针存放某个对象的地址，要想获取该地址，需要使用取地址符&：

```
int ival = 42;
int *p = &ival;   // p存放变量ival的地址，或者说p是指向变量ival的指针
```

因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

### 指针值

指针的值（即地址）应属于下列4种状态之一：

1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，指针没有指向任何对象。
4. 无效指针，上述情况之外的其他值。

试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检査此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。

尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针(假定的)对象的行为不被允许。如果这样做了，后果也无法预计。

### 利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符\*来访问该对象：

```
int ival = 42;
int *p = &ival; // p存放着变量ival的地址，或者说p是指向变量ival的指针
cout << *p;     // 由符号\*得到指针p所指的对象，输出42
```

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：

```
*p = 0;       // 由符号*得到指针p所指的对象，即可经由p为变量ival赋值
cout << *p;   // 输出0
```

### 空指针

空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：

```
int *p1 = nullptr;    // 等价于int *p1 = 0;
int *p2 = 0;          // 直接将p2初始化为字面常量0
// 需要首先#include cstdlib
int *p3 = NULL;       // 等价于int *p3 = 0;
```

把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。

```
int zero = 0;
pi = zero;      // 错误：不能把int变量直接赋给指针
```

### 赋值和指针

指针和引用都能提供对其他对象的间接访问,然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

指针和它存放的地址之间就没有这种限制了。和其他任何变量（只要不是引用）一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。

### 其他指针操作

只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则类似，如果指针的值是0，条件取false，任何非0指针对应的条件值都是true。

对于两个类型相同的合法指针，可以用相等操作符（==）或不相等操作符（!=）来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。这里两个指针存放的地址值相同（两个指针相等）有三种可能：它们都为空、都指向同一个对象，或者都指向了同一个对象的下一地址。需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。

### void* 指针

void\*是一种特殊的指针类型，可用于存放任意对象的地址。一个void\*指针存放着个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：

```
double obj = 3.14, *pd = &obj; 
void *pv = &obj;  
pv = pd;
```

利用void\*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void\*指针。不能直接操作void\*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。概括说来，以void\*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。

## 2.3.3 理解复合类型的声明

一条定义语句可能定义出不同类型的变量：

```
// i是一个int型的数，p是一个int型指针，r是一个int型引用
int i = 1024, *p = &i, &r = i;
```

### 定义多个变量

经常有一种观点会误以为，在定义语句中，类型修饰符（\*或&）作用于本次定义的全部变量。造成这种错误看法的原因有很多，其中之一是我们可以把空格写在类型修饰符和变量名中间：

```
int* p;		// 合法但是容易产生误导
```

```
int * p1, p2; // p1是指向int的指针，p2是int
```

涉及指针或引用的声明，一般有两种写法。第一种把修饰符和变量标识符写在一起：

```
int *p1, *p2; // p1和p2都是指向int的指针
```

这种形式着重强调变量具有的复合类型。第二种把修饰符和类型名卸载一起，并且每条语句只定义一个变量：

```
int* p1;	// p1是指向int的指针
int* p2;	// p2是指向int的指针
```

这种形式着重强调本次声明定义了一种复合类型。

### 指向指针的指针

一般来说，声明符连写在一起时，按照其逻辑关系详加解释即可。以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到零一个指针当中。

通过\*的个数可以区分指针的级别。也就是说，\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针，以此类推：

```
int ival = 1024;
int *pi = &ival;	// pi指向一个int型的数
int **ppi = &pi;	// ppi指向一个int型的指针
```

解引用int型的指针会得到一个int型的数，同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用。

### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```
int i = 42;
int *p;			// p是一个int型指针
int *&r = p;	// r是一个对指针p的引用
```

要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号\*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。
