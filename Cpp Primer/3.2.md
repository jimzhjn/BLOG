# 3.2 标准库类型string

标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中：

```
#include <string>
using std::string;
```

## 3.2.1 定义和初始化string对象

如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。

```
string s1;          // 默认初始化，s1是一个空字符串
string s2 = s1;     // s2是s1的副本
string s3 = "hiya"; // s3是该字符串字面值的副本
string s4(10, 'c'); // s4的内容是cccccccccc
```

### 直接初始化和拷贝初始化

如果使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。
如果不使用等号，执行的是直接初始化。

当初始值只有一个时，使用直接初始化或拷贝初始化都行，如果像s4需要用到多个值，一般来说智能使用直接初始化。

```
string s5 = "hiya"; // 拷贝初始化
string s6 ("hiya"); // 直接初始化
string s7(10, 'c'); // 直接初始化
```

## 3.2.2 string对象上的操作

一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，也能定义<<、+等各种运算符在该类对象上的新含义。

|                |                   |
| -------------- | --------------------------|
| os<<s          | 将s写到输出流os当中，返回os |
| is>>s          | 从is中读取字符串赋给s，字符串以孔板分割，返回is |
| getline(is, s) | 从is中读取一行赋给s，返回is |
| s.empty()      | s为空返回true，否则返回false |
| s.size()       | 返回s中字符的个数 |
| s[n]           | 返回s中第n个字符的引用，位置n从0计起 |
| s1+s2          | 返回s1和s2连接后的结果|
| s1=s2          | 用s2的副本代替s1中原来的字符 |
| s1==s2         | 如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感 |
| s1!=s2         | 如果s1和s2中所含的字符不完全一样，则它们不相等；string对象的相等性判断对字母的大小写敏感 |
| <, <=, >, >=   | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感 |

### 读写string对象

```
int main()
{
    string s;
    cin >> s;
    cout << s << endl;
    return 0;
}
```

在执行读取操作时，string对象会自动忽略开头的空白字符并从第一个真正的字符开始读起，直到遇见下一处空白为止。如果程序的输入是“    Hello World!    ”则输出将是“Hello”。

### 读取未知数量的string对象

```
int main()
{
    string word;
    while(cin >> word)
        cout << word << endl;
    return 0;
}
```

### 使用getline读取一整行

有时候我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的>>运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。

和输入运算符一样，getline也会返回它的流参数，也能用getline的结果作为条件。

```
int main()
{
    string line;
    while(getline(cin,line));
        cout << line << endl;
    return 0;
}
```

### string的empty和size操作

只输出非空的行：

```
int main()
{
    string line;
    while(getline(cin,line));
        if(!line.empty())
            cout << line << endl;
    return 0;
}
```

size函数返回string对象的长度（即string对象中字符的个数），可以使用size函数只输出长度超过80个字符的行：

```
int main()
{
    string line;
    while(getline(cin,line));
        if(line.size() > 80)
            cout << line << endl;
    return 0;
}
```

### string::size_type类型

对于size函数来说，返回的是string::size_type类型的值。

string类及其他大多数标准类型都定义了几种配套的类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性。在具体使用的时候，通过作用域操作符来表明名字size_type是在类string中定义的。

由于size函数返回的是一个无符号整型数，因此如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。

### 比较string对象

string类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较string对象中的字符，并且对大小写敏感。

相等性运算符分别检验两个string对象相等或不相等，string对象相等意味着它们的长度相同而且所包含的字符也全都相同。关系运算符<、<=、>、>=分别检验一个string对象是否小于、小于等于、大于、大于等于另外一个string对象。这些运算符都依照（大小写敏感的）字典顺序：

1. 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。

2. 如果两个string对象在某些对应位置上不一致，则string对象比较的假爱国其实是string对象中第一对相异字符比较的结果。

下面是string对象比较的一个示例：

```
string str = "Hello";
string phrase = "Hello World";
string slang = "Hiya";
```

根据规则1可判断，对象str小于对象phrase；根据规则2可判断，对象slang既大于str也大于phrase。

### 为string对象赋值

