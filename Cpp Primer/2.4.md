# 2.4 const限定符

希望定义值不能被改变的变量，可以用关键字const对变量类型加以限定：

```
const int bufSize = 512; // 输入缓冲区大小
```

任何试图为bufSize赋值的行为都将引发错误。

因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。初始值可以是任意复杂的表达式。

### 初始化和const

对象的类型决定了其上的操作。与非const类型所能参与的操作相比，const类型的对象能完成其中大部分，但也不是所有的操作都适合。主要的限制就是只能在const类型的对象上执行不改变其内容的操作。

在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是 const都无关紧要：

```
int i = 42;
const int ci = i;	// 正确：i的值被拷贝给了ci
int j = ci;			// 正确：ci的值被拷贝给了j
```

### 默认状态下，const对象仅在文件内有效

当以编译时初始化的方式定义一个const对象时，编译器将在编译过程中把用到该变量的地方都替换成对应的值。

为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到这一点,就必须在每一个用到变量的文件中都有对它的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他(非常量)对象一样工作，也就是说,只在一个文件中定义const，而在其他多个文件中声明并使用它。

解决的办法是，对于const变量不管是声明还是定义都添加eκtern关键字，这样只需定义一次就可以了：

```
// file_1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_1.h头文件
extern const int bufSize; // 与file_1.cc中定义的bufSize是同一个
```

如上述程序所示，file_1.cc定义并初始化了bufsize。因为这条语句包含了初始值，所以它(显然)是一次定义。然而，因为bufsize是一个常量，必须用extern加以限定使其被其他文件使用。
file_1.h头文件中的声明也由extern做了限定，其作用是指明bufsize并非本文件所独有，它的定义将在别处出现。

## 2.4.1 const的引用

可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```
const int ci = 1024;
const int &r1 = ci;		// 正确：引用及其对应的对象都是常量
r1 = 42;				// 错误：r1是对常量的引用
int &r2 = ci;			// 错误：试图让一个非常量引用指向一个常量对象
```

### 初始化和对const的引用

引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表
达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式:

```
int i = 42;
const int &r1 = i;		// 允许将const int&绑定到一个普通int对象上
const int &r2 = 42;		// 正确：r2是一个常量引用
const int &r3 = r1 *2;	// 正确：r3是一个常量引用
int &r4 = r1 * 2;		// 错误：r4是一个普通的非常量引用
```

要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：

```
double dval = 3.14;
const int &ri = dval;
```

此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval确实一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式：

```
const int temp = dval;	// 由双精度浮点数生成一个临时的整型变量
cosnt int &ri = temp;	// 让ri绑定这个临时变量
```

在这种情况下，ri绑定了一个临时量对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。

接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值,这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时量而非dva1。程序员既然让ri引用dva1，就肯定想通过ri改变dva1的值，否则干什么要给ri赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。

### 对const的引用可能引用一个并非const的对象

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```
int i = 42;		
int &r1 = i;		// 引用r1绑定对象i
const int &r2 = i;	// r2也绑定对象i，但是不允许通过r2修改i的值
r1 = 0;				// r1并非常量，i的值修改为0
r2 = 0;				// 错误：r2是一个常量引用
```

r2绑定(非常量)整数ⅰ是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。

## 2.4.2 指针和const

与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针，不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：

```
const double pi = 3.14;		// pi是个常量，ta的值不能改变
double *ptr = &pi;			// 错误：ptr是一个普通指针
const double *cptr = *pi;	// 正确：cptr可以指向一个双精度常量
*cptr = 42;					// 错误：不能给*cptr赋值
```

指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：

```
double dval = 3.14;		// dval是一个双精度浮点数，它的值可以改变
cptr = &dval;			// 正确：但是不能通过cptr改变dval的值
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

### const指针

指针是对象，因此允许把指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，则它的值就不能改变了。把\*放在const关键字之前用以说明指针是一个常量。

```
int errNumb = 0;
int *const curErr = *errNumb;	// curErr将一直指向errNumb
const double pi = 3.14159;
const double *const pip = &pi;	// pip是一个指向常量对象的常量指针
```

指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象还是pip自己存储的地址都不能改变你。相反的。curErr指向的是一个非常量整数，就可以用curErr去修改errNumb。

## 2.4.3 顶层const

顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量。

顶层const可以表示任意的对象是常量，底层常量则与指针和引用等复合类型的基本类型部分有关。指针类型既可以是顶层const，也可以是底层const。

```
int i = 0;
int *const p1 = &i;			// 不嫩改变p1的值，这是一个顶层const
const int ci = 42;			// 不能改变ci的值，这是一个顶层const
const int *p2 = &ci;		// 允许该表p2的值，这是一个底层const
const int *const p3 = p2;	// 靠右的const是顶层const，靠左的是底层const
const int &r = ci;			// 用于声明引用的const都是底层const
```

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受影响：

```
i = ci;		// 正确：拷贝ci的值，ci是一个顶层const，对此操作无影响
p2 = p3;	// 正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响
```

执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。

底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行：

```
int *p = p3;		// 错误：p3包含底层const的定义，而p没有
p2 = p3;			// 正确：p2和p3都是底层const
p2 = &i;			// 正确：int*能转换成const int*
int &r = ci;		// 错误：普通的int&不能绑定到int常量上
const int &r2 = i;	// 正确：const int&可以绑定到一个普通int上
```

## 2.4.4 constexpr和常量表达式

常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：

```
const int max_files = 20;			// max_files是常量表达式
const int limit = max_files +1;		// limit是常量表达式
int sdaff_size = 27;				// staff_size不是常量表达式
const int sz = get_size();			// sz不是常量表达式
```

### constexpr变量

在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并未常量表达式的情况。

C++11规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：

```
cosntexpr int mf = 20;			// 20是常量表达式
constexpr int limit = mf + 1;	// mf + 1是常量表达式
constexpr int sz = size();		// 只有当size是一个constexpr函数时才是一条正确的声明语句
```

一般来说，如果认定变量是一个常量表达式，就把它声明成constexpr类型。

### 字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。算术类型、引用和指针都属于字面值类型。

尽管指着和引用都等定义成constrxpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储预某个固定地址中的对象。

### 指针和constexpr

在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：

```
const int *p = nullprt;		// p是一个指向整型常量的指针
constexpr int *q = nullptr;	// q是一个指向整数常量的指针
```

p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。

与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：

```
constexpr int *np = nullptr;	// np是一个指向整数的常量指针，其值为空
int j = 0;
constexpr int i = 42;			// i的类型是整型常量
// i和j都必须定义在函数体之外
constexpr const int *p = &i;	// p是常量指针，指向整型常量i
constexpr int *p1 = &j;			// p1是常量指针，指向整数j 
```
